\section{Imperative Algorithmen}
\begin{itemize}
 \item Basis für imperative Programmiersprachen wie C, Pascal, Modula, Basic, PHP, \dots
 \item bekannteste/häufigste Art Alg. zu formulieren
 \item Alternative: Deklarative Programmierung z.B. \\
 funktionale Programmiersprachen wie z.B \\
 Lisp, Scheme, Haskell, \dots
\end{itemize}

\subsection{Ein- und Ausgabe}
 C++ Beispiel
 \begin{lstlisting}
int a;
cin >> a; //Eingabe des Wertes von a ueber Konsole
cout << "Sie haben" << a << "eingegeben" << ende; // Ausgabe
 \end{lstlisting}

\subsection{Verzweigungen (bedingte Anweisung)}
Mit Verzweigungen können in Abhängigkeit einer Bedingung unterschiedliche Anweisungen ausgeführt werden. \\
\underline{Syntax:} \\
\begin{lstlisting}
if (BEDINGUNG) ANWEISUNG;
else ANWEISUNG2;
\end{lstlisting}
\underline{Interpretation:} \\
Führe ANWEISUNG1 aus, falls die boolsche BEDINGUNG wahr (true) ist, ansonsten führe ANWEISUNG2 aus. (Der Else-Teil ist optional) \\
C++ Beispiel:
\begin{lstlisting}
if (a<0) cout << "a ist negativ" << endl;
else cout << "a ist positiv" << endl;

bool b = ((a % 2) == 0); // b wird true, falls a modulo 2 null ist
if(b) cout << "a ist gerade" << endl;
\end{lstlisting}

~\\ 
Eine ANWEISUNG darf auch ein mit Klammern \{\} zusammengefasster Block von mehreren Anweisungen sein.
\newpage
\underline{Syntax:} \\
\begin{lstlisting}
if (BEDINGUNG)
{
	Anweisung 1.1
	Anweisung 1.2
}
\end{lstlisting}

\begin{table}[h]
	\caption[ModuloTabelle]{Modulo Tabelle}
	\begin{center}
	\begin{tabular}{c|c|c|c|c}
		a & $a/2$ & a\%2 & $a/3$ & a\%3 \\
		\hline
		0 & 0 & 0 & 0 & 0\\
		1 & 0 & 1 & 0 & 1 \\
		2 & 1 & 0 & 0 & 2 \\
	\end{tabular}
	\end{center}
\end{table}

\subsection{Schleifen (Wiederholungen)}
Wiederholte Ausführung von Anweisungen in Abhängigkeit von einer Bedingung. \\
\underline{Syntax:}
\begin{lstlisting}
while (BEDINGUNG) ANWEISUNG;
\end{lstlisting}
\underline{Interpretation:} Solang die boolsche BEDINGUNG wahr ist, wiederhole ANWEISUNG. \\
C++ Beispiel:
\begin{lstlisting}
int a = -1;
while (a<0) cin >> a; // Wiederholte Eingabe von a, bis a postitiv ist
// Ausgabe aller Zahlen von 0 bis a:
int b = 0; // Startwert
while ( b <= a ) // Schleife laeuft solang b<=a
{
	cout << b << endl; // Ausgabe
	b = b + 1; // Hochzaehlen von b
}
\end{lstlisting}
Alternativ kann auch die for-Schleife benutzt werden. \\
\underline{Syntax:}
\begin{lstlisting}
for ( STARTANWEISUNG; BEDINGUNG; ZAEHLANWEISUNG ) ANWEISUNG;
\end{lstlisting}
\underline{Interpretation:} Führe zu Beginn einmal die Startanweisung aus, solang die boolsche BEDINGUNG wahr ist, wiederhole erst ANWEISUNG dann ZAEHLANWEISUNG. \\
\newpage
C++ Beispiel:
\begin{lstlisting}
for ( int b = 0; b <= a; b = b + 1 ) // Ausgabe aller Zahlen von 0 bis a.
{
	cout << b << endl;
}
\end{lstlisting}

\subsection{Prozeduren/Funktionen (Unterprogramme)}
Zusammenfassung von mehreren Anweisungen zu einer Anweisung. Bestehend aus einem RÜCKGABETYP, dem FUNKTIONSNAMEN und einer Liste von Parametern. \\
\underline{Syntax:}
\begin{lstlisting}
RUECKGABETYP FUNKTIONSNAME ( PARAM1, PARAM2,... )
\end{lstlisting}
C++ Beispiel:
\begin{lstlisting}
int max( int a, int b ) // Selbstdefinierte Funktion "max"
{
	if ( a > b ) return a; // gibt a zurueck
	else return b; // gibt b zurueck
}

-------------------

int m, n;
m = max( 2,5 ); // m wird auf 5 gesetzt
n = max( 8,m ); // n wird auf 8 gesetzt
\end{lstlisting}
Ganz Ähnlich ist die mathematische Definition: 
\[
max (a,b) - \left\{\begin{array}{cl}  \mbox{a falls }a>b\\ b \mbox{ sonst} \end{array}\right.
\]
Funktionsaufrufe können verschachtelt werden
\begin{lstlisting}
n = max( 8, max( 2,5 ) );
\end{lstlisting}
C++ Beispiel: Funktion zur Berechnung von $f(x) = x^2 +2x +1$
\begin{lstlisting}
float f( float x )
{
	return x * x + 2*x - 1
}

-------------------

float y = f( 3.4 )
\end{lstlisting}
Wenn die Prozedur keine Rückgabe hat, ist der RUECKGABETYP = void
\begin{lstlisting}
void SchreibWas() // Prozedur ohne RUECKGABE und ohne Parameter
{
	cout << "Test" << endl;
}
\end{lstlisting}
Der Einstiegspunkt eines Programms ist bei C/C++ auch eine Funktion mit Namen \glqq main\grqq
\begin{lstlisting}
int main()
{
	int x,n;
	SchreibWas();
	cout << "Zahl eingeben";
	cin >> x;
	n = max( x,5);
	...
	return 0; // Fehlercode
}
\end{lstlisting}

\subsection{Strukturierung von Algorithmen/Programmen}
Systematischer, übersichtlicher Aufbau; insbesondere bei größeren Programmen
\begin{itemize}
\item Zum Entwurf und zur Darstellung von Algorithmen: \underline{Struktogramme} (nach Nassi-Shneiderman): \\
Linearer Ablauf (Sequenz) Verzweigung (Alternative) und Wiederholung (Iteration) \\
( Hier müssen noch mit zB. TikZ Bilder gemalt werden\dots )
\item Alternative
\begin{itemize}
\item[-] Ablauf-/Flussdiagramme (Auch hier fehlt das Bild\dots)
\end{itemize}
\item UML (Unified Modeling Language) \\
Insbesondere objektorientiert
\end{itemize}
\subsection{Beispiel: Euklidischer Algorithmus zur Berechnung des ggT}
Problem: Entwickeln sie ein Programm zum Kürzen eines Bruches.
\[
\frac{x}{y} = \frac{12}{24} = \frac{1}{2}
\]
Teilproblem: Berechnung des größten gemeinsamen Teilers. \\
\underline{Algorithmus:} \\
Gegeben: Zwei zahlen $x,y (element) \mathbb{N}$ \\
Gesucht: ggT(x,y) \\
Vorgehensweise: von der jeweils größeren Zahl die kleinere Zahl solang subtrahieren, bis beide Zahlen gleich sind => Ergebnis. \\
(Muss noch als Bild realisiert werden) \\
Eingabe $x,y$ \\
solang $x \neq y$ \\
 x>y \\
 ja	nein \\
 x= x-y | y=y-x \\
Ausgabe x \\
Beispiel: ggT(12,20)
\begin{table}[h]
	\caption[ggT Beispiel]{ggT Tabelle}
	\begin{center}
	\begin{tabular}{c|c|c}
		~& $x$ & $y$\\
		\hline
		Start & 12 & 20\\
		nach Schritt 1 & 12 & 8 \\
		nach Schritt 2 & 4 & 8 \\
		nach Schritt 3 & 4 & 4 \\
	\end{tabular}
	\end{center}
\end{table}

\subsection{Parameterübertragung bei Prozeduren/Funktionen}
\begin{itemize}
\item \underline{Werteaufruf} (siehe bisherige Bsp.) \\
Übergabeparameter sind lokale Größen, Sie werden beim Funktionsaufruf in lokale (nur für die Funktion sichtbare Variablen) kopiert.
\item \underline{Referenzaufruf} Speicherort der Größen wird übergeben, d.h. Referenz auf den Inhalt der Variablen. \\
In C mit Hilfe von Zeigern realisiert.
C++ Beispiel
\begin{lstlisting}
int QuadratSumme(int x, int y)
{
	x = x*x;
	y = y*y;
	return x + y;
}

.....

int x = 5;
int y = 3;
int a = QuadratSumme(x,y); // a wird 34
cout << "x=" << x << " y=" << endl; // Ausgabe: x = 5, y = 3

\end{lstlisting}
Der Wert von x und y ändert sich durch den Funktionsaufruf nicht.
\begin{lstlisting}
int QuadratSumme(int &x, int &y)
{
	x = x*x;
	y = y*y;
	return x + y;
}

.....

int x = 5;
int y = 3;
int a = QuadratSumme(x,y); // a wird 34
cout << "x=" << x << " y=" << endl;
// Ausgabe: x = 25, y = 9, wegen der &-Zeichen!
\end{lstlisting}
Bei Ausführung mit Referenzaufruf sind die Werte von x und y verändert!

Beispiel: Funktion die den Inhalt zweier Variablen vertauscht.
\begin{lstlisting}
// void SwapValues(int x, int y)
void SwapValues(int &x, int &y)
{
	int tmp = x;
	x = y;
	// y = x;
	y = tmp;
}

--------------

int x = 5;
int y = 3;
SwapValues(x,y);
\end{lstlisting}
\end{itemize}

\subsection{Beispiel: Berechnung von Fibonacci-Zahlen}
Jede Fibonacci-Zahl ist gleich der Summe der beiden vorhergehenden Fibonacci-Zahlen:
\[
F_0 = 0, F1 = 1; \mbox{für } n > 1: F_n = F_{n-1} + F_{n-2}
\]
\[
\mbox{Folge: } 0, 1, 1, 2, 3, 5, 6, 13, ....
\]
C++ Beispiel:
\begin{lstlisting}
int fib(int n) // Funktion zur Berechnung der n-ten Fibonacci-Zahl
{
	int n2 = 0;
	int n1 = 1;
	int Ergebnis = n1 +n2;
	
	if (n<=0) return 0;
	
	for (int i=2; i<=n, i=i+1)
	{
		Ergebnis = n1 +n2;
		n2 = n1;
		n1 = ergebnis;
	}
	return ergebnis;
}
\end{lstlisting}
\begin{table}[h]
	\caption[Beispiel fib(4)]{fib(4)}
	\begin{center}
	\begin{tabular}{c|c|c|c|c}
		fib(4) & i & n1 & n2 & ergebnis\\
		\hline
		Initial & 2 & 1 & 0 & 1 \\
		Nach 1. Schleifendurchlauf & 3 & 1 & 1 & 1 \\
		Nach 2. Schleifendurchlauf & 4 & 2 & 1 & 2 \\
		Nach 3. Schleifendurchlauf & 5 & 3 & 2 & 3 \\

	\end{tabular}
	\end{center}
\end{table}

\subsection{Rekursionen}
Prozeduren können sich selbst direkt oder indirekt aufrufen. \\
Bsp: Fibonacci-Zahlen rekursiv: $ F_0 = 0, F_1=1; \mbox{für } n>1: F_n = F_{n-1} + F_{n+2} $
C/C++:
\begin{lstlisting}
int fib{int n}
{
	if (n<=0) return 0; // Abbruchbedingungen
	if (n==1) return 1; // Abbruchbedingungen
	return fib(n-1) + fib(n-2); // Rekursionsschritt
}
\end{lstlisting}
Ablaufbeispiel fit(4) \\
(An dieser Stelle sollte eines erstellt werden...)\\
\begin{itemize}
\item Beispiel ineffizienter als iterative Lösung( mit fortschleife), da identische Berechnungen mehrfach wiederholt werden müssen.
\item Oft lassen sich Algorithmen durch Rekursion einfach und anschaulicher Formulieren.
\end{itemize}

\subsection{Grundlegende statische Datenstrukturen}
\begin{itemize}
\item statisch = konstante Anzahl von Variablen bzw. konstante Größen \\
\underline{Array:} Vektor bzw. Feld aus Elementen \underline{desselben} Datentyps
in C/C++:
\begin{lstlisting}
int a[100]; // Deklaration eines Arrays mit 100 Integer-Werten 0-99!
\end{lstlisting}
\underline{Zugriffsbeispiel:}
\begin{lstlisting}
for (int i=0; i<100; i=i+1)
{
	a[i] = i*i;
}
\end{lstlisting}
\begin{table}[h]
	\caption[Array Access Beispiel]{Array Access}
	\begin{center}
	\begin{tabular}{c|c}
		Index & Inhalt\\
		\hline
		0 & 0\\
		2 & 4\\
		... & ...\\
		99 & 9801\\
	\end{tabular}
	\end{center}
\end{table}

\end{itemize}

